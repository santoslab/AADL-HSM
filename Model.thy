chapter "Representing AADL Model Information"

text \<open>This chapter provides definitions for representing AADL 
static model information and associated model well-formedness specifications.

The static model structure is designed to represent HAMR-relevant content from a
AADL system instance model \cite{Feiler?}.   
Given a system model in the AADL sublanguage processed by HAMR, 
HAMR can generate instances of the types defined in this theory.  This provides the
basis for proving properties about system's structure and behavior. 

\edcomment{ToDo: Describe the distinction between the instance model and the 
         information presented here.}

The theory uses Isabelle's Set and Map theories to represent model structures,
but includes some additional helper functions in the SetsAndMaps theory.\<close>

theory Model
  imports Main SetsAndMaps
begin

section "Identifiers"

text \<open>This section includes types for representing different types of identifiers.\<close>

subsection "Port Identifiers @{term PortId}"

text \<open>Port is the main category of feature appearing on the interface of AADL software components.
AADL tools typicially will need some concise way of uniquely refering to ports.
When generating a model representation
from AADL source, HAMR will generate a unique natural number identifier for each port, which is used throughout the HAMR 
run-time infrastructure. (ToDo: add remark about new representation using Slang range types.\<close>

datatype PortId = PortId nat

text \<open>Sets of port identifiers are frequently used in the model representation, so we introduce an
appropriate type synonym.\<close>

type_synonym PortIds = "PortId set"

subsection "Component Identifiers @{term CompId}"

text \<open>Component identifier definitions are similar to those for port identifiers.  {\bf Note:} 
      In the current AADL formalization, 
      threads are the only category of components represented.\<close>

datatype CompId = CompId nat

type_synonym CompIds = "CompId set"

subsection "Variable Identifiers @{term CompId}"

text \<open>Variable identifiers are also similar to port identifiers, except that strings are used 
     for readability instead of numbers. \<close>

text \<open>
\edcomment{ToDo: Rename the following to VarId and VarIds to match 
the other ID domains.}\<close>

datatype Var = Var string

type_synonym Vars = "Var set"

section "Ports Descriptors"

text \<open>Port descriptors combine pieces of information from the AADL instance model
into a single structure that provides attributes of a component port.  
The descriptor includes the port's direction 
(in or out), kind (Event, Data, or Event Data), size (i.e., the size
of the buffer associated with the port) and other user-specified 
properties of the port that are recognized by HAMR.\<close>

text \<open>@{term PortDirection} indicates the directionality of the port.  
Note that HAMR only accepts unidirectional ports.  AADL's bi-directional "in out" ports are
disallowed because they complicate analysis, semantics, and code generation.\<close>

datatype PortDirection = 
  In | Out

text \<open>@{term PortKind} indicates the possible AADL port category.  
\emph{Event} ports  model interrupt signals
or other notification-oriented messages without payloads.
\emph{Data} ports model shared memory between components or
distributed memory services where an update to a distributed memory
cell is automatically propagated to other components that declare
access to the cell.  \emph{Event data} ports model
asynchronous messages with payloads, such as in publish-subscribe
frameworks).  Definitions in XXX cross-reference PortState.thy XXX specify
the state representation for storage associated with ports.  
Inputs to event and event data ports are buffered. The
buffer sizes and overflow policies can be configured per port using
standardized AADL properties.  Inputs to data ports are not buffered;
newly arriving data overwrites the previous value.\<close>

datatype PortKind = 
  Event | Data | EventData

text \<open>The @{term PortDescr} includes the following fields
\begin{itemize}
\item name - the printable name of the port for reporting and debugging purposes,
\item id - the unique identifier for the port, as generated by the HAMR code generator,
\item compId - the unique identifier for the component to which this port belongs,
\item direction - the direction of the port (in or out)
\item kind - the AADL port category for the port (event, data, or eventdata),
\item size - the size of the buffer associated with the port, as declared by the Queue\_Size 
port property in the AADL model (see the AADL standard Section 8.3).  When a size is not specified in the AADL model, 
the size value defaults to 1).  Data ports always have a size of 1.
\end{itemize}
\<close>

record PortDescr =
  name :: "string" 
  id :: "PortId" 
  compId :: "CompId" 
  direction :: PortDirection
  kind :: PortKind
  size :: "nat"    (* ToDo (from John): Assess if we should do a better job reconciling this field name with AADL property Max_Queue_Size *)
  urgency :: "nat"  (* ToDo (from John): Assess if we should do a better job reconciling this field name with AADL property Max_Queue_Size *)
  (* ToDo (from John): Add port overflow stategy and connect this field with the strategy in Queue *)

subsection \<open>Port Descriptor Well-formedness\<close>

text \<open>A port descriptor is well-formed iff
\begin{itemize}
\item the queue size specified in the port descriptor is greater than 0.
\item if the port is a data port, then its queue size must be equal to 1 (as specified 
in the AADL standard Section 8.3 (3)).
\end{itemize}
\<close>

definition wf_PortDescr :: "PortDescr \<Rightarrow> bool"
  where "wf_PortDescr pd \<equiv> (PortDescr.size pd > 0) 
                         \<and> (PortDescr.kind pd = Data \<longrightarrow> PortDescr.size pd = 1)"

subsection \<open>Helper Functions for Working with Ports and Port Descriptors\<close>

text \<open>The following function can be used to abbreviate the declaration of 
port descriptors.\<close>

fun mkPortDescr where "mkPortDescr n i ci d k s u 
      = \<lparr> name= n, id=i, compId= ci, direction=d, kind= k, size= s, urgency= u \<rparr>"

text \<open>The following helper functions query properties of ports as captured in port descriptors.\<close>

text \<open>Is the port an input port?\<close>

fun isInPD :: "PortDescr \<Rightarrow> bool" where
 "isInPD pd = (direction pd = In)"

text \<open>Is the port an output port?\<close>

fun isOutPD :: "PortDescr \<Rightarrow> bool" where
 "isOutPD pd = (direction pd = Out)"

text \<open>Is the port a data port?\<close>

fun isDataPD :: "PortDescr \<Rightarrow> bool" where
 "isDataPD pd = (kind pd = Data)"

text \<open>Is the port an event port?\<close>

fun isEventPD :: "PortDescr \<Rightarrow> bool" where
 "isEventPD pd = (kind pd = Event)"

text \<open>Is the port an event data port?\<close>

fun isEventDataPD :: "PortDescr \<Rightarrow> bool" where
 "isEventDataPD pd = (kind pd = EventData)"

text \<open>Is the port an event-like port? Note: we use the term \emph{event-like}
to refer to ports that are either event ports or event data ports.  
This combined reference is useful because event-like ports are queued
and have similar port update semantics, whereas data ports are not queued.
\<close>

fun isEventLikePD :: "PortDescr \<Rightarrow> bool" where
 "isEventLikePD pd = ((kind pd = Event) \<or> (kind pd = EventData))"


section "Component Descriptors"

text \<open>Similar to port descriptors, Component Descriptors 
combine pieces of information from the AADL instance model
into a single structure that provides attributes of a component.  
In the current formalization, only Thread components are represented.
Therefore, properties included in the component descriptor pertain to 
AADL Thread components.\<close>

text \<open>The following data type represents possible values of 
the AADL Dispatch\_Protocol Thread property (See the AADL standard Section 5.4.2 (45). 
Periodic threads are dispatched at regular intervals as defined by the 
AADL Period property (time and associated timing properties are not represented
currently).   Sporadic threads are dispatched up the arrival of messages
on event-like ports.  The specific conditions for thread dispatching are formalized
in DispatchLogic.thy XXXX cross reference XXXX.
HAMR currently does not support the remaining AADL dispatch protocols (Aperiodic, 
Timed, Hybrid).\<close>

datatype DispatchProtocol = 
  Periodic | Sporadic

text \<open>The @{term CompDescr} includes the following fields
\begin{itemize}
\item name - the printable name of the component for reporting and debugging purposes,
\item id - the unique identifier for the component, as generated by the HAMR code generator,
\item portIds - set of unique identifiers for the ports that are declared on the interface
      of the component,  for the component to which this port belongs,
\item dispatchProtocol - the value of the AADL property Dispatch\_Protocol for this (thread) component,
\item dispatchTriggers - the set of identifiers for event-like input ports that can act as dispatch
triggers for this thread (for a longer discussion, see XXXX DispatchLogic.thy XXX),
\item compVars - the set of identifiers for variables that contribute to the behavior
of the component, as specified by GUMBO contract declarations.
\end{itemize}
\<close>

record CompDescr = 
  name :: "string"
  id :: "CompId" (* unique id for component *)
  portIds :: "PortIds" (* ports belonging to this component *)
  dispatchProtocol :: "DispatchProtocol"  
  dispatchTriggers :: "PortIds" (* ids of ports that can trigger a dispatch *)
  compVars :: "Vars"

subsection \<open>Helper Functions for Working with Components and Component Descriptors\<close>

text \<open>The following function can be used to abbreviate the declaration of 
component descriptors.\<close>

fun mkCompDescr where "mkCompDescr n i pis dp dts v = 
  \<lparr> name= n,  id=i, portIds= pis, dispatchProtocol= dp, dispatchTriggers= dts, compVars= v \<rparr>"

text \<open>The following helper functions query properties of components as captured in 
      component descriptors.\<close>

text \<open>Is the component a periodic thread?\<close>

fun isPeriodicCD :: "CompDescr \<Rightarrow> bool" where
 "isPeriodicCD cd = (dispatchProtocol cd = Periodic)"

text \<open>Is the component a sporadic thread?\<close>

fun isSporadicCD :: "CompDescr \<Rightarrow> bool" where
 "isSporadicCD cd = (dispatchProtocol cd = Sporadic)"


section "Connections"

text \<open>Connections are represented as a map from a connection source @{term PortId} 
 to a set of one or more target @{term PortIds}.\<close>

type_synonym Conns = "(PortId, PortIds) map"

section "Models"

text \<open>The complete static model consists of three maps (lookup tables):
\begin{itemize}
\item modelCompDescrs: associates component ids to component descriptors,
\item modelPortDescrs: associates port ids to port descriptors,
\item modelConns: associates each source port id to a set of target port ids to which it is connected.
\end{itemize}
\<close>

record Model =
  modelCompDescrs :: "(CompId, CompDescr) map" 
  modelPortDescrs :: "(PortId, PortDescr) map" 
  modelConns :: "Conns"
 
text \<open>A helper function for abbreviating the construction of model structures.\<close>

text \<open>\edcomment{I'm pretty sure I saw a built-in notation for this in the 
      Isabelle tutorial (i.e., check to see if we can use the built in
      notation and avoid making our own everywhere.}\<close>

fun mkModel where "mkModel compdescrs portdescrs conns = 
  \<lparr> modelCompDescrs= compdescrs,  modelPortDescrs= portdescrs,  
    modelConns= conns \<rparr>"


(*================ H e l p e r     F u n c t i o n s ===================*)

section "Model Helper Functions"

text \<open>
This section defines helper function for accessing model elements.
\<close>

subsection \<open>Model-wide Queries About Components and Ports\<close>

text \<open>
The first set of helper functions are queries across an entire
model (not limited to a particular component).
\<close>

text \<open>Return the component identifiers in model m.\<close>
fun modelCIDs:: "Model \<Rightarrow> CompId set"
  where "modelCIDs m = dom (modelCompDescrs m)"

text \<open>Return the port identifiers in model m.\<close>
fun modelPIDs:: "Model \<Rightarrow> PortId set"
  where "modelPIDs m = dom (modelPortDescrs m)"

text \<open>Does model m include a component (id) c?\<close>
fun inModelCID :: "Model \<Rightarrow> CompId \<Rightarrow> bool"
  where "inModelCID m c = (c \<in> modelCIDs m)"

text \<open>Does model m include a port (id) p?\<close>
fun inModelPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool" 
  where "inModelPID m p = (p \<in> modelPIDs m)"

text \<open>Does model m include a input port (id) p?\<close>
fun isInPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool" 
  where "isInPID m p = (direction (modelPortDescrs m $ p) = In)"

text \<open>Does model m include an output port (id) p?\<close>
fun isOutPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool"
  where "isOutPID m p = (direction (modelPortDescrs m $ p) = Out)"

text \<open>Does model m include a port (id) p with queue capacity n?\<close>
fun isSizePID :: "Model \<Rightarrow> PortId \<Rightarrow> nat \<Rightarrow> bool"
  where "isSizePID m p n = (size (modelPortDescrs m $ p) = n)"

text \<open>Return the queue capacity of port (id) p in model m.\<close>
fun sizePID :: "Model \<Rightarrow> PortId \<Rightarrow> nat"
  where "sizePID m p = (size (modelPortDescrs m $ p))"

text \<open>Return the kind (data, event, event data) of port (id) p in model m.\<close>
fun kindPID :: "Model \<Rightarrow> PortId \<Rightarrow> PortKind"
  where "kindPID m p = (kind (modelPortDescrs m $ p))"

text \<open>Does model m include a data port (id) p?\<close>
fun isDataPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool"
  where "isDataPID m p = (kindPID m p = Data)"

text \<open>Does model m include an event port (id) p?\<close>
fun isEventPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventPID m p = (kindPID m p = Event)"

text \<open>Does model m include an event data port (id) p?\<close>
fun isEventDataPID :: "Model \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventDataPID m p = (kindPID m p = EventData)"

text \<open>Does model m include an event-like port (id) p?\<close>
fun isEventLikePID :: "Model \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventLikePID m p = ((kindPID m p = Event) \<or> (kindPID m p = EventData))"

text \<open>Return the urgency of port (id) p in model m.\<close>
fun urgencyPID :: "Model \<Rightarrow> PortId \<Rightarrow> nat"
  where "urgencyPID m p = (urgency (modelPortDescrs m $ p))"



subsection \<open>Queries About Ports Associated With a Specific Component\<close>

text \<open>
The second set of helper functions support queries about
properties of a particular component, which can be indicated
by its id (i.e. @{term CompId}) or component descriptor (i.e. @{term CompDescr})
\<close>

text \<open>In model m, does component (id) c have a data port (id) p?\<close>
fun isPortOfCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool" 
  where "isPortOfCIDPID  m c p = (p \<in> (portIds ((modelCompDescrs m) $ c)))"

text \<open>In model m, does component (descriptor) cd have a var (id) v?\<close>
fun isVarOfCD :: "Model \<Rightarrow> CompDescr \<Rightarrow> Var \<Rightarrow> bool"
  where "isVarOfCD m cd v = (v \<in> (compVars cd))"

text \<open>In model m, does component (id) c have a var (id) v?\<close>
fun isVarOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> Var \<Rightarrow> bool"
  where "isVarOfCID m c v = isVarOfCD m ((modelCompDescrs m) $ c) v"

text \<open>In model m, does component (descriptor) cd have an input port (id) p?\<close>
fun isInCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInCDPID m cd p = (p \<in> (portIds cd) \<and> isInPD ((modelPortDescrs m) $ p))"

text \<open>In model m, does component (id) c have an input port (id) p?\<close>
fun isInCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInCIDPID m c = isInCDPID m ((modelCompDescrs m) $ c)"

text \<open>In model m, does component (descriptor) cd have an output port (id) p?"\<close>
fun isOutCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isOutCDPID m cd p = (p \<in> (portIds cd) \<and> isOutPD ((modelPortDescrs m) $ p))"

text \<open>In model m, does component (id) c have an output port (id) p?"\<close>
fun isOutCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isOutCIDPID m c = isOutCDPID m ((modelCompDescrs m) $ c)"

text \<open>In model m, does component (descriptor) cd have a data port (id) p?"\<close>
fun isDataCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isDataCDPID m cd p = (p \<in> (portIds cd) \<and> isDataPD ((modelPortDescrs m) $ p))"

text \<open>In model m, does component (id) c have a data port (id) p?"\<close>
fun isDataCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isDataCIDPID m c = isDataCDPID m (modelCompDescrs m $ c)"

text \<open>In model m, does component (descriptor) cd have an event port (id) p?"\<close>
fun isEventCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventCDPID m cd p = (p \<in> (portIds cd) \<and> isEventPD ((modelPortDescrs m) $ p))"

text \<open>In model m, does component (id) c have an event port (id) p?"\<close>
fun isEventCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventCIDPID m c = isEventCDPID m ((modelCompDescrs m) $ c)"

text \<open>In model m, does component (descriptor) cd have an event-like port (id) p?"\<close>
fun isEventLikeCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventLikeCDPID m cd p = (p \<in> (portIds cd) \<and> isEventLikePD ((modelPortDescrs m) $ p))"

text \<open>In model m, does component (id) c have an event-like port (id) p?"\<close>
fun isEventLikeCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isEventLikeCIDPID m c = isEventCDPID m ((modelCompDescrs m) $ c)"

(* new - need to test *)

text \<open>In model m, does component (descriptor) cd have a input data port (id) p?"\<close>
fun isInDataCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInDataCDPID m cd p = (p \<in> (portIds cd) 
                                \<and> (let pd = ((modelPortDescrs m) $ p)
                                   in (isInPD pd \<and> isDataPD pd)))"

text \<open>In model m, does component (id) c have an input data port (id) p?"\<close>
fun isInDataCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInDataCIDPID m c = isInDataCDPID m ((modelCompDescrs m) $ c)"

text \<open>In model m, does component (descriptor) cd have an input event-like port (id) p?"\<close>
fun isInEventLikeCDPID :: "Model \<Rightarrow> CompDescr \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInEventLikeCDPID m cd p = (p \<in> (portIds cd) 
                                \<and> (let pd = ((modelPortDescrs m) $ p)
                                   in (isInPD pd \<and> isEventLikePD pd)))"

text \<open>In model m, does component (id) c have an input event-like port (id) p?"\<close>
fun isInEventLikeCIDPID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId \<Rightarrow> bool"
  where "isInEventLikeCIDPID m c = isInEventLikeCDPID m ((modelCompDescrs m) $ c)"

text \<open>Return the ports belonging to component (id) c in model m.\<close>
fun portsOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId set" 
  where "portsOfCID  m c = portIds ((modelCompDescrs m) $ c)"

text \<open>Return the input ports belonging to component (id) c in model m.\<close>
fun inPortsOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId set"
  where "inPortsOfCID m c = {p . isInCIDPID m c p}"

text \<open>Return the input data ports belonging to component (id) c in model m.\<close>
fun inDataPortsOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId set"
  where "inDataPortsOfCID m c = {p . isInDataCIDPID m c p}"

text \<open>Return the input event-like ports belonging to component (id) c in model m.\<close>
fun inEventLikePortsOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId set"
  where "inEventLikePortsOfCID m c = {p . isInEventLikeCIDPID m c p}"

text \<open>Return the dispatch triggers (port ids)belonging to component (id) c in model m.\<close>
fun dispatchTriggersOfCID :: "Model \<Rightarrow> CompId \<Rightarrow> PortId set" 
  where "dispatchTriggersOfCID  m c = dispatchTriggers ((modelCompDescrs m) $ c)"

(*========= M o d e l   W e l l f o r m e d n e s s   P r o p e r t i e s  ===========*)

section \<open>Model Well-formedness Properties\<close>

text \<open>
We now define a collection of well-formedness properties for models. 
The notion of well-formed model (@{term wf_Model}) is defined as the 
conjunction of all of these properties.

When HAMR generates an Isabelle representation of an AADL, all
of these properties are automatically proven.
\<close>


(*
 To Add
   * no data port fan in (Abdullah is working on this)
   * no reuse of var ids across components (may not need to this -- does Stefan need it?)
   * We currently have dispatchTriggers is non-empty, but we should also constrain
     further to say that only EventLike input ports can be dispatch triggers. 
   * add constraints on Urgency ?
*)

text \<open>Each port descriptor in the modelPortDescrs map is well-formed.\<close> 
definition wf_Model_PortDescr :: "Model \<Rightarrow> bool" 
  where "wf_Model_PortDescr m \<equiv> 
  (\<forall>p \<in> dom (modelPortDescrs m). wf_PortDescr ((modelPortDescrs m) $ p))"

text \<open>For each entry (p:: PortId, pd:: PortDescr) in the port descriptors map, 
   the port id in the descriptor pd matches p.\<close> 
definition wf_Model_PortDescrsIds :: "Model \<Rightarrow> bool" 
  where "wf_Model_PortDescrsIds m \<equiv> 
  (\<forall>p \<in> dom (modelPortDescrs m). p = PortDescr.id ((modelPortDescrs m) $ p))"

text \<open>For each entry (c:: CompId, cd:: CompDescr) in the component descriptors map, 
   the comp id in the descriptor cd matches c.\<close> 
definition wf_Model_CompDescrsIds :: "Model \<Rightarrow> bool" 
  where "wf_Model_CompDescrsIds m \<equiv> 
  (\<forall>c \<in> dom (modelCompDescrs m) . c = CompDescr.id ((modelCompDescrs m) $ c))"

text \<open>For each entry (p:: PortId, pd:: PortDescr) in the port descriptors map, 
   the comp id indicating the enclosing component for the port is in the
   domain of the component descriptors map.\<close>
definition wf_Model_PortDescrsCompId :: "Model \<Rightarrow> bool" 
  where "wf_Model_PortDescrsCompId m \<equiv> 
  (\<forall>p \<in> dom (modelPortDescrs m). PortDescr.compId ((modelPortDescrs m) $ p) \<in> dom (modelCompDescrs m))"

text \<open>For each entry (c:: CompId, cd:: CompDescr) in the component descriptors map, 
   the port ids of component's contained ports are contained in the domain of the 
   port descriptor map.\<close>
definition wf_Model_CompDescrsContainedPortIds :: "Model \<Rightarrow> bool" 
  where "wf_Model_CompDescrsContainedPortIds m \<equiv> 
  (\<forall>c \<in> dom (modelCompDescrs m).  (CompDescr.portIds ((modelCompDescrs m) $ c)) \<subseteq> dom (modelPortDescrs m))"

text \<open>For each pair of component ids c, d in the model,
      the sets of ids of ports belonging to those components are disjoint.\<close>
definition wf_Model_DisjointPortIds :: "Model \<Rightarrow> bool"
  where "wf_Model_DisjointPortIds m \<equiv>
  (\<forall>c \<in> dom (modelCompDescrs m). 
   \<forall>d \<in> dom (modelCompDescrs m). 
   (c \<noteq> d \<longrightarrow> ((CompDescr.portIds ((modelCompDescrs m) $ c) \<inter> CompDescr.portIds ((modelCompDescrs m) $ d)) = {})))"

text \<open>For each entry (p:: PortId, s:: PortId set) in the connections map,  
   the port id p and the port ids s = {p1, ..., pn} are in the domain of the 
   port descriptor map.\<close>
definition wf_Model_ConnsPortIds :: "Model \<Rightarrow> bool" 
  where "wf_Model_ConnsPortIds m \<equiv> 
  (\<forall>p \<in> dom (modelConns m).   (p \<in> dom (modelPortDescrs m))
                            \<and> ((modelConns m) $ p) \<subseteq> dom (modelPortDescrs m))"

text \<open>For each entry (p:: PortId, s:: PortId set) in the connections map,  
      p is an output port and the ports in p' in s are input ports
      and the port kinds of p and p' match.\<close>
definition wf_Model_ConnsPortCategories :: "Model \<Rightarrow> bool" 
  where "wf_Model_ConnsPortCategories m \<equiv> 
  (\<forall>p \<in> dom (modelConns m).(isOutPID m p) \<and> 
   (\<forall>p'\<in> ((modelConns m) $ p).(isInPID m p') \<and> (kindPID m p = kindPID m p')))"
                          
text \<open>For each entry (p:: PortId, pd:: PortDescr) in the port map,  
      if p is an in data port, then it has a size of at most one.\<close>
definition wf_Model_InDataPorts :: "Model \<Rightarrow> bool"
  where "wf_Model_InDataPorts m \<equiv>
  (\<forall>p \<in> dom (modelPortDescrs m). 
      (isInPID m p) \<and> (isDataPD (modelPortDescrs m $ p)) 
          \<longrightarrow> (sizePID m p) \<le> 1)" (* ToDo: seems like this is redundant with wf_PortDescr *)

text \<open>For each entry (c:: CompId, cd:: CompDescr) in the component descriptors map, 
if c is Sporadic, then cd's dispatchTriggers is non-empty.
HAMR currently ignores dispatch trigger declarations in periodic ports.
NOTE: the AADL standard does not require that dispatch triggers are declared in
Sporadic threads.  The standard specifies that, in the absence of dispatch
trigger declarations in Sporadic threads, ALL event-like ports are treated
as dispatch triggers by default.  We do not include the logic for "by default".
Instead, we assume that the HAMR Isabelle model generation strategy will
look for any dispatch trigger declarations for the thread in the AADL model,
and if no such declarations exist, the translation will 
explicitly insert in dispatchTriggers field in the CompDescr, a set containing
the set of event-like input ports for the thread.  This simplifies the logic
in the Isabelle model and HAMR code-base.
\<close>

definition wf_Model_SporadicComp :: "Model \<Rightarrow> bool"
  where "wf_Model_SporadicComp m \<equiv>
  (\<forall>c \<in> dom (modelCompDescrs m). (isSporadicCD (modelCompDescrs m $ c)) 
    \<longrightarrow> (dispatchTriggers (modelCompDescrs m $ c)) \<noteq> empty)"

(* Should the following be added - no dispatch triggers are declared in periodic threads?

definition wf_Model_PeriodicComp :: "Model \<Rightarrow> bool"
  where "wf_Model_PeriodicComp m \<equiv>
  (\<forall>c \<in> dom (modelCompDescrs m). (isPeriodicCD (modelCompDescrs m $ c)) 
    \<longrightarrow> (dispatchTriggers (modelCompDescrs m $ c)) = empty)"
*)

text \<open>
The following top-level definition for well-formed models
is the conjunction of the properties above.\<close>

definition wf_Model :: "Model \<Rightarrow> bool"
  where "wf_Model m \<equiv>
           wf_Model_PortDescr m
         \<and> wf_Model_PortDescrsIds m
         \<and> wf_Model_CompDescrsIds m
         \<and> wf_Model_PortDescrsCompId m
         \<and> wf_Model_CompDescrsContainedPortIds m 
         \<and> wf_Model_DisjointPortIds m
         \<and> wf_Model_ConnsPortIds m
         \<and> wf_Model_ConnsPortCategories m
         \<and> wf_Model_InDataPorts m
         \<and> wf_Model_SporadicComp m"

text \<open>
Finiteness of models is implied by other wf conditions, e.g. @{term wf_SystemSchedule}, but
might occasionally needed to be assumed explicitly.\<close>

definition finite_Model :: "Model \<Rightarrow> bool"
  where "finite_Model m \<equiv> finite (dom (modelCompDescrs m)) \<and> finite (dom (modelPortDescrs m))"

(*========= M o d e l   W e l l f o r m e d n e s s   P r o p e r t i e s  ===========*)

section \<open>Properties Derived from Well-formedness\<close>

lemma wf_model_implies_data_ports_capacity: 
  assumes wf_m: "wf_Model m"
      and p_in_m: "p \<in> dom (modelPortDescrs m)"
      and p_is_dataport: "isDataPID m p"
    shows "(sizePID m p) = 1"
proof - 
  from p_is_dataport have h1: "(kind (modelPortDescrs m $ p)) = Data" by auto 
  from wf_m have h2: "wf_Model_PortDescr m" unfolding wf_Model_def by auto
  from h2 have h3: "wf_PortDescr ((modelPortDescrs m) $ p)" by (simp add: p_in_m wf_Model_PortDescr_def)
  from h3 h1 show ?thesis by (simp add: wf_PortDescr_def)
qed

lemma  
  assumes wf_m: "wf_Model m"
      and p_in_m: "p \<in> dom (modelPortDescrs m)"
      and p_is_dataport: "isDataPID m p"
    shows "(sizePID m p) = 1"
proof - 
  from p_is_dataport have h1: "(kind (modelPortDescrs m $ p)) = Data" by auto 
  from wf_m have h3: "wf_PortDescr ((modelPortDescrs m) $ p)" 
    by (auto simp add: p_in_m wf_Model_def wf_Model_PortDescr_def wf_PortDescr_def)
  from h3 h1 show ?thesis by (simp add: wf_PortDescr_def)
qed

lemma  
 "\<lbrakk>wf_Model m; isDataPID m p\<rbrakk> \<Longrightarrow> p \<in> dom (modelPortDescrs m)"
  apply (auto simp add: wf_Model_def wf_Model_PortDescr_def wf_PortDescr_def)   
  sorry


end